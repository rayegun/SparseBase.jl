var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SparseBase","category":"page"},{"location":"#SparseBase","page":"Home","title":"SparseBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SparseBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SparseBase]","category":"page"},{"location":"#SparseBase.CoordinateStore","page":"Home","title":"SparseBase.CoordinateStore","text":"CoordinateStore\n\n\n\n\n\n","category":"type"},{"location":"#SparseBase.UniformValue","page":"Home","title":"SparseBase.UniformValue","text":"UniformValue{T}\n\nSimple wrapper struct that denotes a uniform value for array input (all stored values are equal to a single value such as true).\n\n\n\n\n\n","category":"type"},{"location":"#SparseBase.convertinnerstore","page":"Home","title":"SparseBase.convertinnerstore","text":"convertinnerstore(T::Type{<:AbstractSparseStore}, A)\n\nConvert A into a similar format, with the internal sparse store converted to     T.\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.deuniform!-Tuple{Any}","page":"Home","title":"SparseBase.deuniform!","text":"deuniform!(A)::A\n\nIf an array supports an iso representation convert it to the expected non-iso representation internally.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.filltype-Tuple{Type}","page":"Home","title":"SparseBase.filltype","text":"filltype(A)\n\nType of implicit values of A. Most arrays either have no fill, or only support fill in the same domain as eltype(A).\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.findstored","page":"Home","title":"SparseBase.findstored","text":"findstored(A)\n\nAn iterable over the stored indices and values of A.  May be a direct view into internals,  but this is not a requirement, and so shouldn't be used to modify A. \n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.getfill","page":"Home","title":"SparseBase.getfill","text":"getfill(A)\n\nThe value taken by all non-stored/implicit indices of A.\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.hasfixedsparsity-Tuple{Any}","page":"Home","title":"SparseBase.hasfixedsparsity","text":"hasfixedsparsity(::Type{A})::Bool\n\nTrue if the sparsity pattern of the type A may be changed. A Diagonal type, for instance, may not have its sparsity pattern changed.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.iscoalesced-Tuple{Any}","page":"Home","title":"SparseBase.iscoalesced","text":"iscoalesced(::Type{A})::Bool = true\n\nWhether each stored index is unique.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.isopaque-Tuple{Any}","page":"Home","title":"SparseBase.isopaque","text":"isopaque(::Type{A})::Bool\n\nTrue if internals may not be accessed directly. C owned types set this to true.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.isuniformvalued-Tuple{Any}","page":"Home","title":"SparseBase.isuniformvalued","text":"isuniformvalued(A)::Bool\n\nTrue if a type contains a single value across all stored indices.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.mapstored!","page":"Home","title":"SparseBase.mapstored!","text":"mapstored[!](f, [E], [C], A)\nmapstored(f, [E], A ∪ B)\nmapstored(f, [E], (A ∩ B) ∪ C)\n\nMap a function over the stored values of A(, B, C, ...).\n\nUnions and intersections of A, B, C... operate elementwise over the unions and intersections of the patterns of those matrices.\n\nIssues:\n\nThis could potentially lead to wrapper hell. I hope it doesn't, I think we would have\n\nUnionPattern, IntersectionPattern (maybe ComplementPattern?). I don't think these wrappers are quite as bad as the ones in LinAlg, but I could be wrong.\n\nCurrent implementations (SSGrB) only implement mapstored[!](f, [C], A), mapstored[!](f, [C], A ∪ B) and mapstored[!](f, [C], A ∩ B)\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.npending-Tuple{Any}","page":"Home","title":"SparseBase.npending","text":"npending(A)::Integer\n\nThe number of pending insertions into A.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.nstored-Tuple{Any}","page":"Home","title":"SparseBase.nstored","text":"nstored(A)::Integer\n\nNumber of stored elements in A. In the dense case this is length(A)\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.nzombies-Tuple{Any}","page":"Home","title":"SparseBase.nzombies","text":"nzombies(A)::Integer\n\nThe number of pending deletions of values in A.\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.setfill","page":"Home","title":"SparseBase.setfill","text":"setfill!(A, fill)::A\nsetfill(A, fill)::B\n\nSet the value taken by implicit indices of A to a new value. setfill produces a shallow copy of A with the new fill value.\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.storedindices","page":"Home","title":"SparseBase.storedindices","text":"storedindices(A)\n\nIterables over the stored indices of A. May be a direct view into internals, but is invalid to modify. May be lazy iterables.\n\n\n\n\n\n","category":"function"},{"location":"#SparseBase.storedvalues","page":"Home","title":"SparseBase.storedvalues","text":"storedvalues(A)\n\nAn iterable over the stored values of A. May be a direct view into internals,  but this is not a requirement, and so shouldn't be used to modify A.  Must be returned in the same order as storedindices.\n\n\n\n\n\n","category":"function"}]
}
